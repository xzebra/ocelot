package server

import (
	"crypto/rand"
	"crypto/x509"
	"errors"
	"ocelot/global"

	"github.com/Tnze/go-mc/net"
	"github.com/Tnze/go-mc/net/packet"
)

const (
	// Client packets
	LoginStart          byte = 0x00
	EncryptionResponse  byte = 0x01
	LoginPluginResponse byte = 0x02

	// Server packets
	Disconnect         byte = 0x00
	EncryptionRequest  byte = 0x01
	LoginSuccess       byte = 0x02
	SetCompression     byte = 0x03
	LoginPluginRequest byte = 0x04
)

var (
	errNoLoginStart     = errors.New("no login start packet")
	errPublicKeyMarshal = errors.New("couldn't marshal public key in ASN.1 format")
)

type encryptionRequestPacket struct {
	// ServerID appears to be empty
	ServerID packet.String
	// PublicKeyLength is the length of PublicKey
	PublicKeyLength packet.VarInt
	// PublicKey
	PublicKey packet.ByteArray
	// VerifyTokenLength Length of VerifyToken.
	// Always 4 for Notchian servers.
	VerifyTokenLength packet.VarInt
	// VerifyToken is a sequence of random bytes
	// generated by the server.
	VerifyToken packet.ByteArray
}

func (p encryptionRequestPacket) Marshal() (pk packet.Packet) {
	return packet.Marshal(
		EncryptionRequest,
		p.ServerID,
		p.PublicKeyLength,
		p.PublicKey,
		p.VerifyTokenLength,
		p.VerifyToken,
	)
}

func handleLogin(conn net.Conn) error {
	var username packet.String
	// Login process (C = client, S = server):

	// C→S: Login Start
	received, err := conn.ReadPacket()
	if err != nil {
		return errConnClosed
	}
	if received.ID != LoginStart {
		return errNoLoginStart
	}

	err = received.Scan(&username)
	if err != nil {
		return errScan
	}

	// For unauthenticated and localhost connections there is no encryption.
	// S→C: Encryption Request
	asn1PublicKey, err := x509.MarshalPKIXPublicKey(global.PublicKey)
	if err != nil {
		return errPublicKeyMarshal
	}

	token := make([]byte, 4)
	rand.Read(token)

	conn.WritePacket(encryptionRequestPacket{
		ServerID:          "",
		PublicKeyLength:   packet.VarInt(len(asn1PublicKey)),
		PublicKey:         asn1PublicKey,
		VerifyTokenLength: 4,
		VerifyToken:       token,
	}.Marshal())

	// (Client auth via mojang web)
	// The client will generate a random 16-byte shared secret, to be used
	// with the AES/CFB8 stream cipher. It then encrypts it with the server's
	// public key (PKCS#1 v1.5 padded), and also encrypts the verify token
	// received. Both byte arrays in the Encryption Response packet will be
	// 128 bytes long because of the padding.

	// The server decrypts the shared secret and token using its private key,
	// and checks if the token is the same. It then sends a Login Success,
	// and enables AES/CFB8 encryption. For the Initial Vector (IV) and AES
	// setup, both sides use the shared secret as both the IV and the key.
	// Similarly, the client will also enable encryption upon sending Encryption
	// Response. From this point forward, everything is encrypted. Note: the
	// entire packet is encrypted, including the length fields and the packet's data.
	// C→S: Encryption Response

	// Server auth, both enable encryption
	// S→C: Set Compression (optional)
	// S→C: Login Success

	return nil
}
